# Week 1 개인 정리

## ✏️ 배운 내용 요약

  ### 3장 컴포넌트

  ### 컴포넌트란?
  컴포넌트는 UI를 구성하는 독립적이며 재사용 가능한 작은 단위를 말한다. 웹페이지를 기능 단위로 나누는 과정을 추상화 라고 하며, 추상화 과정을 통해 각 기능을 컴포넌트 단위로 구성하여 조합한다.
  - 컴포넌트의 장점
    - 재사용 가능
    - 유지보수 용이
    - 로직 분리 가능
    - 복잡한 상태 관리 가능
 ### 컴포넌트의 종류
 1) 클래스 컴포넌트
  클래스 컴포넌트는 리액트의 컴포넌트 클래스를 상속받아 생성하며 반드시 render() 메소드를 포함해야한다.
  ```js
  import { Component } from 'react';

  class [컴포넌트_이름] extends Component {
    // jsx를 반환하는 render() 메소드
    render() {
        return (...)
    }
  }
  export default [컴포넌트_이름];
  ```
  extends 키워드로 Component 클래스를 상속 받고 render() 메소드는 화면에 보여줄 UI 요소를 반환하는 역할을 한다.

  2) 함수형 컴포넌트
   함수형 컴포넌트는 함수를 사용해 컴포넌트를 작성하는 방식이다. function 키워드로 함수를 선언한 뒤 return문 안에 jsx를 사용해 화면에 표시할 UI 구조를 정의한다.
   ```js
   export default function [컴포넌트_이름]() {
    return (...); //JSX 반환
   }
   ```

   ### 컴포넌트 기초
   | 확장자  | CRA | VITE |
  |--------|-----|------|
  | .js    | .JSX 지원 | .JSX 지원 |
  | .jsx    | .JSX 지원 | .JSX 지원 |
  | .ts    | .JSX 지원 안 함 | .JSX 지원 안 함 |
  | .tsx    | .JSX 지원 | .JSX 지원 |

  ### props 객체란?
  컴포넌트를 값을 속성 형태로 전달하는 객체. 부포 컴포넌트가 자식 컴포넌트에게 넘겨주는 모든 데이터가 담긴 객체라고 할 수 있다.
  
  ### 컴포넌트와 이벤트
  ```js
  <JSXElement 이벤트_속성='이벤트_핸들러' />
  ```
  리액트 주요 이벤트 속성
  | 구분 | 이벤트 | 설명 |
  |------|---------|-------|
  | **마우스 이벤트** | onClick ★ | 클릭했을 때 호출 |
  |  | onDoubleClick | 더블 클릭했을 때 호출 |
  |  | onMouseEnter | 마우스가 요소 위로 올라왔을 때 호출 |
  |  | onMouseLeave | 마우스가 요소에서 벗어났을 때 호출 |
  |  | onMouseMove | 마우스가 요소 위에서 움직일 때 호출 |
  |  | onContextMenu | 마우스 오른쪽 버튼 클릭 시 호출 |
  |  | onDrag | 드래그 중일 때 호출 |
  |  | onDrop | 드래그한 요소를 놓았을 때 호출 |
  |  | onMouseDown | 마우스 버튼을 눌렀을 때 호출 |
  |  | onMouseUp | 마우스 버튼을 눌렀다 뗐을 때 호출 |
  | **키보드 이벤트** | onKeyDown ★ | 키를 눌렀을 때 호출 |
  |  | onKeyUp ★ | 키를 눌렀다 뗐을 때 호출 |
  |  | onKeyPress | 키를 누르고 있을 때 호출(Deprecated 경고: 최신 리액트에선 사용 비권장) |
  | **폼 이벤트** | onChange ★ | 입력값이 변경될 때 호출 |
  |  | onInput | 입력이 발생했을 때 호출 |
  |  | onFocus | 포커스가 들어왔을 때 호출 |
  |  | onBlur | 포커스가 빠져나갈 때 호출 |
  |  | onSubmit ★ | 폼이 제출될 때 호출 |
  | **터치 이벤트** | onTouchStart | 터치가 시작될 때 호출 |
  |  | onTouchMove | 터치 중 움직일 때 호출 |
  |  | onTouchEnd | 터치가 끝날 때 호출 |
  | **기타 이벤트** | onLoad | 이미지, iframe 등이 로드될 때 호출 |
  |  | onError | 로드 중 오류가 발생했을 때 호출 |
  |  | onScroll | 요소가 스크롤될 때 호출 |

  ★ 표시는 자주 사용하는 이벤트 속성
  - 공식 문서 (https://react.dev/reference/react-dom//components/common)
  
  ## 컴포넌트와 상태
  ### 컴포넌트의 상태란
  상태는 컴포넌트에서 사용할 수 있는 데이터로, 시간에 따라 변하고 리액트에서는 상태를 사용해 값이 변경 될 때 컴포넌트를 자동으로 리렌더링 한다.

  ### useState 훅
  함수형 컴포넌트에서 상태를 관리 할 수 있도록 도와주는 훅
  ```js
  const [state, setState] = useState<Type>(initialState);
  ```
  - state : 상태를 저장하는 변수
  - setState : 상태를 변경하는 함수
  - <Type> : 상태의 데이터 타입(생략 가능)
  - initialState : 상태 초기값

  ### useReducer 훅
  상태와 액션을 기반으로 새로운 상태를 만드는 훅

  ```js
  const [state, dispatch] = useReducer<Type>(reducer, initialState)
  ```
  - state: 상태를 저장하는 변수
  - dispatch : 액션을 발생시키는 함수
  - reducer : 이전 상태와 액션을 받아 새로운 상태를 반환하는 함수
  - initialState : 상태 초기값

  ## 조건부 렌더링과 반복 렌더링
  ### 조건부 렌더링
  조건부 렌더링이란 특정 조건에 따라 컴포넌트를 화면에 표시하거나 숨기는 방식으로 동적 UI를 구성 할때 사용한다.
  1) if문 사용
  - if문을 사용해 조건에 따라 렌더링 내용 결정
  - JSX 표현식 내부에서 사용 할 수 없고 컴포넌트 내부의 코드 블록에서 사용해야 함
  2) 삼항 연산자 사용
  - 조건 ? 참일때 결괴 : 거짓일때 결과 형태로 사용
  - JSX 내부에서 인라인으로 사용 할 수 있다
  3) AND 논리 연산자(&&) 사용
  - 조건이 true 일때만 특정 JSX 요소나 컴포넌트를 렌더링
  - 단일 조건으로 UI 제어 할 때 사용 한다
  ### 반복 렌더링
  배열이나 리스트 데이터를 기반으로 동일한 형태의 컴포넌트를 반복해서 렌더링 하는 방식
  1) 배열 사용
  - JSX 내부에서 {배열} 형태로 출력하면 배열의 각 요소가 문자열로 변환 된 뒤 공백 없이 하나로 연결되어 렌더링 된다.
  - 배열에는 JSX요소나 컴포넌트를 포함 할 수 있고 각 요소에 key 속성을 부여 해야 한다.
  2) map() 메소드 사용
  - map() 메소드는 배열의 각 요소를 순회하며 새로운 JSX 요소들로 구성된 배열을 반환 한다. (권장 방식)
  3) 그 밖의 사용법
   - for 문
   - forEach()
   - reduce()

## 폼 다루기
### 폼 정의하기
- 한줄 입력 상자 - <"input">
- 여러줄 입력 상자 - <"textarea">
- 선택 상자 - <"select">
- 체크 박스 - <"input type='checkbox'">
- 라디오 버튼 - <"input type='radio'"> <br>
모든 폼 요소는 <"form"> 태그 안에 포함 되어야 한다

### 제어 컴포넌트
제어 컴포넌트는 입력 값을 상태로 관리하는 방식이다.
useState훅을 사용해 상태를 정의하고 폼 요소의 속성을 사용해 상태를 연결 한다.
```js
const [value, setValue] = useState('');
<input value={value} onChange={(e) => setValue(e.target.value)} />
```
해당 방식 처럼 input에 value prop을 내려주고 input 박스 안 내용이 변할때 setValue를 통해 상태 변경을 해주는 방식이다.

### 비제어 컴포넌트
비제어 컴포넌트는 입력 값을 DOM요소에서 직접 가져오는 방식이다. useRef 훅을 사용해 DOM 요소를 참조하고 값을 읽는다. 입력 요소 마다 ref객체가 필요하고 그룹으로 묶인 입력 값은 FormData.get() 방식으로 추출 할 수 있다.

### 커스텀 훅
커스텀 훅이란 리액트 기본 훅을 조합해 사용자가 직접 정의한 함수이다. 커스텀훅을 사용해 반복 로직을 하나의 함수로 묶거나 복잡한 폼 상태 관리도 더 간단하게 구현 할 수 있다.

### 폼 밸리데이션
사용자가 입력한 값이 올바른 형식과 조건을 만족하는지 검증하는 작업이다.
- 기본 밸리데이션 : html5 내장 속성을 사용하여 검증 하는 방식
- 커스텀 밸리데이션 : 직접 정의해 입력 값을 검사 하는 방식으로 특정 형식이나 범위를 검사하거나 다른 필드와 비교할때 사용한다.
- 라이브러리 사용 : Formik, React Hook Form 같은 라이브러리를 사용하여 상태 관리, 검증, 오류 메세지 표시 등을 자동화 할 수 있다.

## 리액트 라우터로 라우팅 기능 사용하기
### 라우팅이란
사용자가 URL을 입력하거나 버튼을 클릭 했을때 그에 맞는 UI를 보여주는 기능을 말한다.
- SPA(Single Page Application) : 하나의 html로 구성된 애플리케이션
- CSR(Client Side Rendering) : 사용자의 브라우저에서 화면을 렌더링 하는 방식
- MPA(Multi Page Application) : 여러개의 html 페이지로 구성된 애플리케이션
- SSR(Server Side Rendering) : 서버가 요청에 맞는 html을 미리 렌더링해 클라이언트에 전달하는 방식

### 리액트, 리액트 라우터
- 리액트 : SPA 방식에 최적화 된 라이브러리, CSR 방식 기본 사용
- 리액트 라우터 : SPA에서 URL을 클라이언트에서 동적으로 처리 할 수 있게 도와주는 도구이며 컴포넌트 렌더링, 중첩 라우팅, 동적 라우팅, 프로그래밍 방식 네비게이션, 리다이렉션 및 조건부 렌더링 기능을 지원한다.
### 리액트 라우터 기능
1) 중첩 라우트
: 라우트를 계층 구조로 구성해 복잡합 UI 표현
2) 레이아웃 라우트
: 여러 라우트에 공통된 레이아웃을 적용 할 수 있는 상위 라우트
3) 라우트 프리픽스
: 특정 라우트 그룹에 공통 접두사를 지정
4) 동적 세그먼트
: :param 형식으로 URL의 가변 부분을 정의하고 useParams 훅으로 해당 값을 추출 가능
5) 옵셔널 세그먼트
: ? 기호를 사용해 URL 일부를 선택 처리
6) 스플랫
: * 기호를 사용해 모든 경로를 포괄하는 라우트
### 네비게이션 기능
페이지 간 이동을 쉽게 구현 할 수 있도록 제공하는 기능
- Link : 단순 경로 이동만 수행하는 컴포넌트
- NavLink : 현재 경로와 일치하는지 감지하고 isActive 속성을 사용해 활성 상태를 감지 한다

## 💡 느낀 점
코드잇 강의에서 배울때는 왜? 라는 의문이 많았었는데 같은 주제를 책이랑 같이 읽어보면서 강의를 들어보니 이래서 그랬구나 라는 해결이 많이 됐었던것 같습니다. 부족한 부분을 채워주는 부분이 정말 좋았고 할수록 어려운 부분도 있지만 그만큼 재미도 많이 느꼈던것 같습니다.

## 💡 어려운 점
해당 기능들을 어떤식으로 활용을 해야 할지 아직 감이 안잡히는 부분이 있는것 같습니다. 이해는 됐지만 추상화의 과정을 계속 겪어보면서 풀어나가는게 가장 큰 어려움이라고 생각듭니다