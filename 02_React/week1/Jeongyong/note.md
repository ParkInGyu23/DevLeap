# Week 5 개인 정리

## ✏️ 배운 내용 요약

## 2장

## JSX

- 자바스크립트 코드 안에서 HTML과 비슷한 문법을 사용해 UI를 정의할 수 있도록 도와주는 문법 확장
- 자바스크립트 안에서 HTML처럼 생긴 코드를 쓸 수 있게 해주는 문법
- 실행할때는 리액트가 JSX 코드를 자바스크립트 코드로 변환해서 실행

## JSX의 문법적 특징

### 하나의 루트 요소로 반환하기

- JSX로 작성된 컴포넌트는 반드시 하나의 태그(요소)만 반환해야 함
- 기본적으로는 div 태그로 감싸나 불필요한 태그가 추가되기 때문에 프래그먼트를 이용함

### 모든 태그 닫기

- HTML에서는 일부 태그를 닫지 않아도 문제없이 작동하지만 JSX에서는 빈 태그라도 /를 이용해서 닫아줘야 함

### 태그 속성은 카멜 케이스로 작성하기

- JSX는 자바스크립트 문법과 함께 동작하므로 HTML처럼 속성명을 모두 소문자로 작성하면 오류가 발생할 수 있음
- ex) class (X) className(O)
- data-나 aria-로 시작하는 속성은 HTML 표준 규칙을 그대로 따름

### 표현식은 중괄호 안에서 사용하기

- JSX는 중괄호 {} 안에 자바스크립트 표현식을 넣어 사용할 수 있음
- 삼항 연산자, 논리 연산자를 통해 상황에 따른 JSX 요소를 출력할 수 있음

### 인라인 스타일은 객체로 지정하기

- ex) `<h1 style={{color: 'red', backgroundColor: 'lightgray'}}>Styled Text</h1>`

### 중괄호 안에 주석 작성하기

- ex) `{/* 올바른 주석 */}`

## 3장

## 컴포넌트

- UI를 구성하는 독립적이며 재사용 가능한 작은 단위

## 컴포넌트 단위 구성의 이점

1. 재사용 가능: 컴포넌트를 여러 위치에서 반복적으로 사용 가능
2. 유지보수 용이: 컴포넌트를 작게 나누면 각 컴포넌트를 독립적으로 관리할 수 있어 유지보수가 편리
3. 로직 분리 가능: 사용자 인터페이스와 사용자 경험 관련 로직을 컴포넌트별로 분리할 수 있음
4. 복잡한 상태 관리 가능: 컴포넌트를 가능한 한 작은 단위로 나누면 상태 관리가 더 명확해지고 효율적인 렌더링이 가능해짐

## 컴포넌트의 종류

### 클래스 컴포넌트

- ES6에서 도입된 클래스 문법을 사용해 컴포넌트를 정의
- 리액트의 Component 클래스를 상속받아 생성하며, 반드시 render() 메서드를 포함해야 함
- render() 메서드 안에서 컴포넌트가 화면에 보여줄 UI를 반환

```js
// 기본 구조
import { Component } from "react";

class [컴포넌트_이름] extends Component {
  render() {
    return (JSX)
  }
}
export default [컴포넌트_이름];
```

### 함수형 컴포넌트

- 함수를 사용해 컴포넌트를 작성하는 방식
- function 키워드로 함수를 선언, return문 안에 JSX를 사용해 UI 구조 정의
- 함수형 컴포넌트의 이름은 파스칼 케이스로 작성

```js
// 기본 구조
function [컴포넌트_이름] () {
  return (JSX)
}
export default [컴포넌트_이름];
```

## 컴포넌트 기초

### 컴포넌트 확장자

- 관용적으로 자바스크립트 기반 리액트 애플리케이션에서는 .jsx, 타입스크립트 기반의 리액트 애플리케이션에서는 .tsx 확장자 사용

### 컴포넌트의 다른 정의 방식(함수 표현식, 화살표 함수)

```js
// 함수 표현식
const App = function App() {
  return JSX;
};
export default App;
```

```js
// 화살표 함수
const App = () => {
  return JSX;
};
export default App;
```

### 컴포넌트 트리

- 리액트 애플리케이션은 App 컴포넌트에 여러 하위 컴포넌트를 포함하면서 전체 UI를 구성
- 하나의 컴포넌트 안에 또 다른 컴포넌트를 포함하는 방식, 계층적 구조 형성
- 컴포넌트들이 연결된 구조를 컴포넌트 트리라고 함
- App 컴포넌트는 리액트 애플리케이션 가장 바깥쪽에 위치하는 컴포넌트임
- 이럴 때 App를 루트 컴포넌트라고 함

### 리액트 컴포넌트의 주요 특징

1. 계층 구조: 컴포넌트는 부모-자식 관계의 계층 구조를 가짐
2. 단방향 데이터 흐름: 리액트에서는 데이터가 항상 부모에서 자식으로만 흐름
3. 재사용성: 한 번 정의한 컴포넌트는 여러 위치에서 반복해서 사용할 수 있음
4. 상태 관리: 각 컴포넌트는 자신만의 상태(state)를 가질 수 있음
5. 렌더링 최적화: 리액트는 가상 DOM을 사용해 실제 DOM과의 차이를 비교한 뒤 변경된 부분만 최소한으로 업데이트함

## 컴포넌트와 props 객체

### props 객체

- props는 컴포넌트를 마치 HTML 태그처럼 사용해 값을 속성형태로 전달
- 문자열은 따옴표로, 숫자나 표현식은 중괄호로 감싸 전달
- 부모 컴포넌트에서 자식 컴포넌트에 여러 props를 전달하면 리액트 내부에서는 이 데이터를 단일 객체 형태로 전달(props 객체)

### children

- 컴포넌트 태그 사이에 작성된 모든 내용을 하나로 묶어 전달하는 특별한 속성
- 내용이 여러 요소로 구성되었어도 리액트는 이를 자동으로 하나의 children 값으로 처리
- 따라서 한 컴포넌트에 children을 2개 이상 따로 지정할 수는 없음

## 컴포넌트와 이벤트

- 리액트에서는 이벤트 속성을 카멜 케이스로 작성하고, 값으로 함수를 전달함

### 리액트의 주요 이벤트 속성

- 마우스 이벤트 | onClick | 클릭 이벤트 발생 시 호출
- 키보드 이벤트 | onKeyDown | 키를 눌렀을 때 호출
- 폼 이벤트 | onChange | 입력 필드의 값이 변경될 때 호출
- 폼 이벤트 | onSubmit | 폼이 제출될 때 호출

### 이벤트 핸들러

## 4장

## 컴포넌트 상태

- 컴포넌트의 상태란 리액트 컴포넌트 내부에서 관리하는 데이터로, 사용자와의 상호작용에 따라 변경될 수 있는 값

### useState

### useReducer

- 이전 상태와 액션에 따라 새로운 상태를 반환하는 방식

```js
const [state, dispatch] = useReducer(reducer, initialState);
```

## 7장

## 조건부 렌더링

- 특정 조건에 따라 컴포넌트를 화면에 표시하거나 숨기는 방식

### if 문을 사용한 조건부 렌더링

- 코드 가독성과 유지 보수성을 높여줌
- 컴포넌트 내부에서 특정 조건에 따라 서로 다른 UI 요소를 렌더링할 수 있으므로 복잡한 조건 분기를 처리할 때 특히 유용함
- 조건문의 명확한 구조 덕분에 코드의 의도가 분명하게 드러나며, 중첩 조건이나 복잡한 로직도 자연스럽게 표현할 수 있음

### 삼항 연산자를 사용한 조건부 렌더링

- if-else 문보다 더 간결하게 표현할 수 있으며, JSX 내부에서도 인라인 스타일을 사용할 수 있다는 장점이 있음
- 특히 간단한 조건에 따라 UI를 전환해야 하는 경우 유용함

### AND 연산자를 사용한 조건부 렌더링

- 특정 조건이 참일 때만 UI 요소를 렌더링해야 하는 상황에서 특히 유용함

## 반복 렌더링

- 배열이나 리스트 형태의 데이터를 기반으로 여러 컴포넌트를 생성해 일관된 방식으로 화면에 출력하는 기법

## 8장

### 폼 정의하기

- 폼은 사용자가 정보를 입력하고 제출할 수 있도록 구성된 다양한 UI 요소의 집합
- 즉, 웹페이지에서 사용자와 상호작용할 수 있도록 도와주는 중요한 구성 요소

### 대표적인 폼 요소

- 한 줄 입력 상자(<input.>): 이름, 이메일 등 간단한 텍스트를 입력할 때 사용
- 여러 줄 입력 상자(<textarea.>): 긴 글이나 메모와 같은 내용을 입력할 때 사용
- 선택 상자(<select.>): 드롭다운 형태로 여러 옵션 중 하나를 선택할 때 사용
- 체크박스(<input type='checkbox'.>): 여러 옵션을 중복 선택할 때 사용
- 라디오 버튼(<input type='radio'.>): 여러 옵션 중 하나만 선택할 때 사용
- 모든 폼 요소는 보통 <form> 태그 안에 포함되어야 하며, 사용자가 입력한 데이터를 서버로 제출하거나 클라이언트에서 처리 할 수 있도록 함

### 제어 컴포넌트

- 입력 값을 리액트 컴포넌트의 상태로 완전히 관리하는 방식
- 즉, 사용자가 입력한 값을 바로 DOM에 저장하지 않고 먼저 상태에 저장한 뒤 그 값을 화면에 표시하는 구조
- 입력 값이 변경될때마다 상태를 업데이트하고, 상태 값을 다시 입력 요소에 연결, UI와 상태가 항상 일치(동기화)되며, 실시간으로 값을 추적하거나 검증하는 작업이 쉬워짐

### 제어 컴포넌트 작동 순서

1. 상태 정의: useState 훅을 사용해 입력 값을 저장할 상태를 정의
2. 상태 업데이트: 사용자가 값을 입력하면 <input.> 요소의 onChange 속성에 연결된 이벤트 핸들러가 실행되어 입력 값을 상태에 저장
3. 상태와 입력 요소 연결: <input.> 요소의 value 속성을 상태 값으로 설정, <input.> 요소는 리액트의 상태에 의해 제어되고, 항상 최신 상태 값이 화면에 표시됨

### 비제어 컴포넌트

- 폼 요소의 입력 값을 리액트 상태가 아닌 DOM 자체에서 직접 관리하는 방식
- 즉, 사용자가 입력한 값은 컴포넌트의 상태로 저장하지 않고, DOM에 그대로 저장

### useRef

1. useRef 훅으로 참조 생성: useRef 훅으로 참조 객체(ref)를 생성, 이 객체는 나중에 특정 DOM 요소에 연결되어 해당 요소를 직접 제어할 수 있음
2. 입력 요소에 ref 객체 연결: 생성한 ref 객체를 입력 요소의 ref 속성과 연결하면 해당 DOM 노드를 ref.current.value를 사용해 직접 접근 가능

## 13장

### 라우팅 방식 이해하기

- 라우팅이란 사용자가 주소(URL)를 입력하거나 버튼을 클릭했을 때 그에 맞는 화면(UI)을 보여주는 기능을 말함
- 웹 어플리케이션의 구조는 크게 SPA와 MPA로 나눌 수 있음

### 싱글 페이지 어플리케이션(SPA, Single Page Application)

- 말 그대로 하나의 HTML 페이지로 구성된 웹 어플리케이션
- 사용자가 처음 웹사이트에 접속할 때 전체 애플리케이션을 한 번에 불러오며, 이후에는 URL이 변경되더라도 페이지 전체를 로드하지 않고 필요한 부분만 화면에 다시 그려줌
- 리액트와 같은 SPA 프레임워크에서는 클라이언트 사이드 렌더링 방식을 주로 사용함

### 클라이언트 사이드 렌더링(CSR, Client Side Rendering)

- 화면을 서버가 아닌 사용자의 웹 브라우저(클라이언트)에서 자바스크립트를 이용해 직접 렌더링하는 방식
- 이때 서버는 초기 HTML만 전달하고, 이후 필요한 데이터는 API를 통해 서버에서 받아옴
- 웹브라우저는 이 데이터를 바탕으로 UI를 구성
- SPA와 CSR 조합은 페이지가 한 번 로드되면 이후 화면 전환이 빠르고 부드러워 사용자 경험이 우수함
- 필요할 때만 데이터를 받아오기 때문에 효율적
- 하지만 초기 로딩 시 자바스크립트 번들까지 함께 받아야 하므로 첫 화면이 늦게 뜰 수 있음
- 콘텐츠가 웹 브라우저에서 동적으로 생성되어 검색 엔진 최적화에 불리함

### 멀티 페이지 애플리케이션(MPA, Multiple Page Application)

- 여러 HTML 페이지로 구성된 애플리케이션
- MPA 구조에서는 사용자가 다른 페이지로 이동하면 웹 브라우저는 해당 경로에 맞는 새로운 HTML 파일을 서버에 요청하고 전체 페이지를 다시 불러옴
- 이러한 구조에서는 보통 서버 사이드 렌더링 방식을 사용함

### 서버 사이드 렌더링(SSR, Server Side Rendering)

- 서버에서 HTML을 미리 렌더링해 클라이언트에 완성된 페이지를 전달하는 방식
- 이때 서버는 요청된 경로에 따라 HTML을 직접 렌더링하거나 미리 만들어진 HTML 파일을 찾아 클라이언트로 전송합니다.
- MPA는 여러 페이지로 구성되어 있어 SSR 방식과 자연스럽게 연결됨
- MPA와 SSR 조합은 서버가 미리 렌더링한 HTML을 전달하므로 초기 로딩 속도가 빠르고, 콘텐츠가 HTML에 포함되어 있어 SEO에 유리함
- 하지만 페이지를 이동할 때마다 서버에서 새로운 HTML을 받아와야 해서 반응 속도가 느리고, 전체 페이지를 매번 새로 로딩하기 때문에 사용자 경험이 SPA보다 떨어질 수 있음

## 리액트 라우터 다루기

### 라우팅 범위 지정하기

- 리액트 라우터를 기존 리액트 애플리케이션에 적용하려면 가장 먼저 라우팅 컨텍스트를 지정해야 함
- 라우팅 컨텍스트는 라우팅 기능이 적용될 범위를 설정하는 작업으로, Context API에서 전역 상태를 사용할 범위를 지정했던 것과 유사함

- 리액트 라우터에서는 용도에 따라 다음과 같이 4가지 라우팅 컨텍스트 컴포넌트를 제공함

1. **BrowserRouter**: 최신 웹 브라우저에서 제공하는 히스토리 API를 사용해 URL을 관리함, 가장 일반적이며, CSR 환경에서 주로 사용함, 서버가 아닌 클라이언트에서 URL을 처리하므로 현대 웹 애플리케이션에 가장 적합함
2. HashRouter: URL에 해시(#) 기호를 포함해 경로를 구분함, 서버 설정이 필요 없기 때문에 정적 파일 기반 환경에서 유용함
3. MemoryRouter: 주소창을 변경하지 않고, 내부 메모리에서 라우팅 상태를 관리, 주로 테스트 환경이나 MPA 구조에서 사용함, 변경한 URL을 표시하지 않기 때문에 웹 브라우저의 히스토리나 주소창에 영향을 미치지 않음
4. StaticRouter: SSR 환경에서 사용하는 라우터, 클라이언트의 주소창은 변경하지 않고, 서버에서 HTML을 렌더링할 때 사용함

### 라우트 설정하기

- 라우트 설정은 특정 URL 경로를 컴포넌트와 연결하는 작업

1. Route: 하나의 라우트 정보를 정의, path 속성에 URL 경로를, element 속성에 해당 경로에 표시할 컴포넌트를 지정
2. Routes: 여러 개의 Route 컴포넌트를 감싸는 컨테이너 역할을 함, 내부에서 경로를 비교해 현재 URL과 일치하는 첫 번째 Route 컴포넌트를 렌더링 함

### 스플랫

- 리액트 라우터에서는 정의되지 않은 경로를 포괄적으로 처리할 수 있도록 스플랫(splat)이라는 기능을 제공
- 스플랫은 catch-all 또는 와일드카드(wildcard) 라우트라고도 하며, 경로에 '\*' 기호를 사용해 설정함
- '\*' 기호를 사용하면 특정 경로 이후의 모든 하위 경로를 한꺼번에 매칭시킬 수 있음

### 내비게이션 기능 사용하기

- HTML에서는 페이지를 이동할 때 <a.>태그를 사용, 리액트 라우터에서는 SPA 방식으로 작동하므로 Link, NavLink 컴포넌트를 사용

1. Link: 단순히 경로 이동만 수행하는 컴포넌트, 활성 상태 감지는 지원하지 않음
2. NavLink: 현재 경로와 일치하는지 감지할 수 있음, isActive 속성을 사용해 활성 상태를 감지하며, 스타일이나 클래스를 동적으로 설정할 수 있음

### 프로그래밍 방식 라우팅

- 리액트 라우터에서는 useNavigate 훅을 사용해 자바스크립트 코드 안에서 직접 페이지를 이동 할 수 있음
- 이처럼 사용자의 클릭 없이 특정 조건이나 이벤트에 따라 페이지를 전환하는 방식을 프로그래밍 방식 라우팅이라고 함

## 💡 느낀 점

## 💡 어려운 점
